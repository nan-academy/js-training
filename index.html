<!DOCTYPE html>
<html>
<head>
  <title>JS Training</title>
  <meta charset="utf-8">
  <link href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAA/wAAAP///wC0af8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMzMzMzMwADMRERERETMAMxMzMzMxMwAzEyMjIyEzADMSMjIyMTMAMxMjIyMhMwAzEiIiIiEzADMSMjIyMTMAMxIiIiIhMwAzEyMjIyEzADMSIiERETMAMxIiISITMwAzEiIhITMzADMSIiETMzMAMxERETMzMwADMzMzMzMwDAAwAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAADAAwAA" rel="icon" type="image/x-icon">
  <style id="css">
/* LAYOUT */
* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

body {
  position: relative;
  max-width: 85ch;
  margin: 0 auto;
  font-size: 16px;
  font-family: monospace;
  height: 100vh;
}

pre {
  white-space: pre-wrap;
  padding: 16px;
  margin-top: 32px;
}

h1, h2, h3, h4 { font-weight: normal; margin-top: 16px; }
h1 { text-align: center }

div.CodeMirror { height: 100vh }
.error-message { text-align: center }
.test-flash {
  animation-duration: 6000ms;
  animation-iteration-count: 1;
  animation-fill-mode: forwards;
}

a, button, .ui { cursor: pointer; user-select: none }

form {
  padding: 24px;
  text-align: center;
  width: 100%;
}

form label {
  margin-top: 52px;
  display: block;
}
form .range {
  height: 36px;
  display: flex;
  align-items: center;
}

form .min,
form .max,
form input[type="range"] {
  margin: 0 6px;
  width: 33%;
  overflow: hidden;
  text-overflow: ellipsis;
}

form textarea {
  width: 100%;
  margin-top: 18px;
  height: 180px;
  resize: vertical;
  border: none;
  border-radius: 3px;
  font-size: 16px;
  padding: 6px;
  font-weight: bold;
}

form .min { text-align: right }
form .max { text-align: left }

form textarea:focus {
  outline-offset: 3px;
  outline-width: 2px;
  outline-style: dashed;
}
form button {
  border: 2px solid;
  background: transparent;
  padding: 6px;
  border-radius: 8px;
  margin-top: 6px;
  outline: none;
  font-family: monospace;
  font-size: 16px;
  line-height: 22px;
}
form button:focus { outline: none }

.select {
  display: flex;
  justify-content: space-evenly;
  align-items: baseline;
}

.select label {
  border: 3px solid transparent;
  padding: 1px 6px;
}

.select input[type="radio"] { opacity: 0; position: fixed; }
.select input[type="radio"]:checked + label { border-bottom-color: currentColor }
.select input[type="radio"]:focus + label { border: 3px dashed }

/* COLORS */
.editable {
  background-color: var(--b-lime);
}

html, body {
  color: var(--b);
  background: var(--i);
}

pre {
  background: var(--white);
}

mark {
  background: var(--g-lime);
  color: var(--b);
}

@keyframes pass {
  0% { background-color: var(--e-turquoise); color: var(--a-turquoise) }
  2% { background-color: var(--f-turquoise); color: var(--a-turquoise) }
  4% { background-color: var(--g-turquoise); color: var(--b-turquoise) }
  80% { color: var(--d-turquoise) }
  100% {}
}

@keyframes fail {
  0% { background-color: var(--f-red); color: var(--a-red) }
  2% { background-color: var(--g-red); color: var(--a-red) }
  4% { background-color: var(--i-red); color: var(--b-red) }
  80% { color: var(--d-red) }
  100% {}
}

@keyframes start {
  0% { background-color: var(--e-yellow); color: var(--a-yellow) }
  2% { background-color: var(--f-yellow); color: var(--a-yellow) }
  4% { background-color: var(--g-yellow); color: var(--b-yellow) }
  100% { color: var(--d-yellow) }
}

.error-message { color: var(--g-red) }

form { background: var(--i) }
form .min { color: var(--c-orange) }
form .max { color: var(--c-turquoise) }
form textarea:focus { outline-color: var(--c-turquoise) }
form button:focus { color: var(--c-turquoise) }
form button:hover { color: var(--b-turquoise) }
form button {
  color: var(--b);
  background: white;
}

.select .title { color: var(--e) }
.select input[type="radio"]:checked + label { color: var(--c-turquoise) }

/* DARK MODE */
.dark form, html.dark, .dark body {
  color: var(--i);
  background: var(--a);
}

.cm-s-dracula span.cm-comment.subject { color: #a3b5ef }
.dark pre { background: var(--b) }
.dark mark {
  background: var(--b-lime);
  color: var(--white);
}

@keyframes pass-dark {
  0% { background-color: var(--g-turquoise); color: var(--white) }
  2% { background-color: var(--e-turquoise); color: var(--white) }
  4% { background-color: var(--b-turquoise); color: var(--g-turquoise) }
  80% { color: var(--f-turquoise) }
  100% {}
}

@keyframes fail-dark {
  0% { background-color: var(--g-red); color: var(--white) }
  2% { background-color: var(--e-red); color: var(--white) }
  4% { background-color: var(--b-red); color: var(--g-red) }
  80% { color: var(--f-red) }
  100% {}
}

@keyframes start-dark {
  0% { background-color: var(--a-yellow); color: var(--white) }
  2% { background-color: var(--c-yellow); color: var(--white) }
  4% { background-color: var(--b-yellow); color: var(--g-yellow) }
  100% { color: var(--f-yellow) }
}

.dark form .min { color: var(--h-orange) }
.dark form .max { color: var(--h-turquoise) }
.dark form textarea:focus { outline-color: var(--h-turquoise) }
.dark form button:focus { color: var(--h-turquoise) }
.dark form button:hover { color: var(--g-turquoise) }
.dark form button {
  color: white;
  background: inherit;
}

.dark .select .title { color: #a3b5ef }
.dark .select input[type="radio"]:checked + label { color: var(--h-orange) }

/* ROUTING */
#editor, #menu, #feedback { display: none }
.page-editor #editor, .page-menu #menu, .page-feedback #feedback { display: inherit }

.select label { margin-top: 0 }

h2, h3 { color: #A3B5EF }
form h3 {
  margin-top: 48px;
  margin-bottom: 36px; 
}

#menu-content a {
  margin-top: 9px;
  display: block;
  text-decoration: none;
}

a:hover { text-decoration: underline }
a.active:before { content: '/* -- ' }
a.active:after  { content: ' -- */' }

.dark a { color: var(--i) }
.dark a:text-d { color: var(--i) }
.dark a:hover { color: var(--h-turquoise) }

  </style>
<script>
const colorDefs = 'red.orange.yellow.lime.green.turquoise.cyan.blue.purple.fuschia.magenta.pink'.split('.')
document.getElementById('css').innerHTML += `:root {
  --white: #fff;
  --black: #000;
  ${colorDefs.flatMap((name, hue) => [
    `  --${name}: ${hue*30};`,
    ...[...Array(9).keys()].map(i => `  --${(i+10).toString(36)}-${name}: hsl(${hue*30}, 90%, ${(i*10)+10}%);`),
  ]).join('\n')}
  ${[...Array(9).keys()]
    .map(i => `  --${(i+10).toString(36)}: hsl(0, 0%, ${(i*10)+10}%);`).join('\n')}
}
${[...Array(100).keys()].map(n => `
.test-${n}-fail .test-${n} { animation-name: fail }
.test-${n}-pass .test-${n} { animation-name: pass }
.test-${n}-start .test-${n} { animation-name: start }
.dark .test-${n}-fail .test-${n} { animation-name: fail-dark }
.dark .test-${n}-pass .test-${n} { animation-name: pass-dark }
.dark .test-${n}-start .test-${n} { animation-name: start-dark }
`).join('\n')}
`
</script>
</head>
<body>
  <div id="editor"></div>
  <form id="menu">
    <h2>Menu</h2>
    <h3>Settings</h3>
    <div class="select">
      <input type="radio" name="theme" id="light" value="light">
      ‚òÄ <label class="ui" for="light">Light</label>
      <div class="title">/* -- theme -- */</div>
      <input type="radio" name="theme" id="dark" value="dark">
      <label class="ui" for="dark">Dark</label> üåí
    </div>
    <h3>Exercises</h3>
    <div id="menu-content"></div>
    <h3>Actions</h3>
    <button type="button" id="feedback-button">Feedback</button>
  </form>
  <form id="feedback">
    <h2>Feedback</h2>
    <label>
      <div class="title">üë∂ How challenging was this exercise ? ü§ñ</div>
      <div class="range">
        <span class="min">not at all</span>
        <input type="range" name="intelligibility" min="1" max="100" step="0.01">
        <span class="max">too much</span>
      </div>
    </label>
    <label>
      <div class="title">ü§∑ Was the subject intelligible ? üîé</div>
      <div class="range">
        <span class="min">incomprehensible</span>
        <input type="range" name="difficulty" min="1" max="100" step="0.01">
        <span class="max">clear</span>
      </div>
    </label>
    <label>
      <div class="title">üò© Was it enjoyable ? üòÄ</div>
      <div class="range">
        <span class="min">tiring</span>
        <input type="range" name="fun" min="1" max="100" step="0.01">
        <span class="max">fun</span>
      </div>
    </label>
    <label>
      <div class="title">üí© Was it compelling ? üëç</div>
      <div class="range">
        <span class="min">boring</span>
        <input type="range" name="interest" min="1" max="100" step="0.01">
        <span class="max">interesting</span>
      </div>
    </label>
    <label>
      <div class="title">üï≥ How much did you learn ? üéì</div>
      <div class="range">
        <span class="min">nothing</span>
        <input type="range" name="payoff" min="1" max="100" step="0.01">
        <span class="max">a lot</span>
      </div>
    </label>
    <label>
      <span class="title">üôè Please say anything you think could help improve this exercise</span>
      <textarea name="remarks"></textarea>
    </label>
    /* --
    <button type="button" tabindex="-1" id="skip-feedback">‚ùå Cancel (escape) üíî</button>
    -----
    <button type="submit">‚úî Submit (enter) üíö</button>
    -- */
  </form>
  <script>    
const dark = document.getElementById('dark')
const light = document.getElementById('light')

if (localStorage.theme === 'dark' || (localStorage.theme !== 'light' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
  document.documentElement.classList.add('dark')
  dark.checked = true
} else {
  light.checked = true
}
</script>
  <link rel="stylesheet" type="text/css" href="./lib/codemirror.css">
  <script src="./lib/codemirror.js"></script>
  <script type="module">
import { router } from './lib/router.js'
let _module, _loading, _error, _lock, _worker, _save, _activePage

const exerciseProps = {
  feedbackStatus: _ => _ || '',
  feedback: _ => _ || '',
  prompted: _ => Number(_) || 0,
  attempt: _ => Number(_) || 0,
  begin: _ => Number(_) || 0,
  code: _ => _ || '',
  end: _ => Number(_) || 0,
}

const exerciseEntries = Object.entries(exerciseProps)
const buildExerciseStore = hash => Object.fromEntries(exerciseEntries.map(([key,parser]) => {
  const path = `${hash}/${key}`
  const get = () => parser(localStorage[path])
  const set = value => localStorage[path] = value || ''
  const setnx = value => localStorage[path] || set(value)
  return [ key, { get, set, setnx } ]
}))

const store = new Proxy({}, {
  get: (_,k) => k in exerciseProps
    ? (_[location.hash] || (_[location.hash] = buildExerciseStore(location.hash)))[k]
    : (_[k] || (_[k] = buildExerciseStore(k))),
})
  
const menu = document.getElementById('menu-content')
const feedback = document.getElementById('feedback')
const feedbackBtn = document.getElementById('feedback-button')
const inputs = [...feedback.querySelectorAll('textarea, input')]
const remarks = inputs.find(e => e.name === 'remarks')

const ZAP = '// /*/ // ‚ö°'
const DEFAULT_TIMEOUT = 5000
const userContent = 'https://raw.githubusercontent.com'
const localhost = new Set(['localhost', '127.0.0.1'])
const getContent = async (url, exercise) => {
  const res = await fetch(`${url}/exercise/${exercise}.js`)
  if (!res.ok) {
    _module && _module.purge()
    throw Error(`Unable to fetch: ${exercise}.js`)
  }
  return (await res.text()).replace(/\r\n/g, '\n')
}

const defaults = (arr, ...args) => args.map((v, i) => arr[i] || v)
const unslash = str => str.replace(/(^\/+|\/+$)/g, '')
const guessUrl = ({ host, pathname, hostname, origin }) => host.endsWith('.github.io')
  ? [userContent, host.split('.')[0], unslash(pathname), 'gh-pages']
  : localhost.has(hostname)
  ? [origin]
  : [userContent, 'nan-academy', 'js-training', 'master']

const importText = code => import(URL.createObjectURL(new Blob([code], {type : 'text/javascript'})))
const baseUrl = `${location.origin}${location.pathname}`
const contentUrl = guessUrl(location).join('/')
const exec = async code => {
  document.body.className = ''
  const worker = (_worker && !_worker.terminated)
    ? _worker
    : (_worker = new Worker('./lib/worker.js', { type: 'module' }))

  const send = (arg, timeout) => new Promise(s => {
    setTimeout(() => {
      s(false)
      if (worker.terminated) return
      worker.terminated = true
      worker.terminate()
    }, timeout || DEFAULT_TIMEOUT)
    if (worker.terminated) return setTimeout(s, 32)
    worker.addEventListener('message', event => s(event.data), { once: true, passive: true })
    worker.postMessage(arg)
  })

  document.body.classList.add(`test-1-start`)
  const { line, error, count } = await send(code, 10000)
    .then(data => data || ({ error: 'TimeoutError: Worker is stuck' }))
  if (error) {
    document.body.className = 'test-0-fail'
    return _error = line > -1
      ? cmEditor.doc.markText(
        { line: line-1, ch: 0 },
        { line, ch: 0 },
        { className: `test-flash test-0` },
      )
      : cmEditor.doc.addLineWidget(
        (line || cmEditor.doc.size)-1,
        document.createTextNode(error),
        { coverGutter: true, noHScroll: true, className: 'error-message' },
      )
  }

  for (const n of Array(count).keys()) {
    document.body.classList.add(`test-${n+1}-start`)
    const minWait = new Promise(s => setTimeout(s, 60))
    const pass = await send(n).catch(false)
    await minWait
    document.body.classList.remove(`test-${n+1}-start`)
    document.body.classList.add(`test-${n+1}-${pass ? 'pass' : 'fail'}`)
  }
}

const loadModule = ({ next, exercises }) => {
  const entries = Object.entries(exercises).map(([k, v], i) => [ k, { ...v, name: k, i }])
  for (const [,e] of entries) {
    e.prev = entries[e.i - 1] && entries[e.i - 1][1]
    e.next = entries[e.i + 1] && entries[e.i + 1][1]
  }
  _module = { next, entries, exercises: Object.fromEntries(entries) }
}

const mark = ({ from: f, to: t, ...opts }) => cmEditor.doc.markText(
  { line: f, ch: 0 },
  { line: t, ch: 0 },
  opts,
)

const countLines = str => {
  let total = 0
  for (const c of str) { c === '\n' && (total++) }
  return total
}

const skipButton = document.getElementById('skip-feedback')
const normalize = ([k, str]) => [k, String(str||'').replace(/‚Üµ/g, '‚Ü≤').replace(/\n/g, '‚Üµ')]
const parametrize = data => `${new URLSearchParams(Object.entries(data).map(normalize))}`
const formatInput = e => `${e.name}_${e.value}`.replace(/~/g, '-')
const encodeFeedback = () => parametrize({
  hash: feedback.hash,
  attempt: store[feedback.hash].attempt || 0,
  code: inputs.map(formatInput).join('~'),
})

const decodeFeedback = () => {
  const stored = store[feedback.hash].feedback.get()
  if (!stored) return {}
  const encodedValues = new URLSearchParams(stored).get('code')
  const result = {}
  for (const part of encodedValues.split('~')) {
    const [key] = part.split('_', 1)
    result[key] = part.slice(key.length + 1).replace(/‚Üµ/g, '\n')
  }
  return result
}

const loadHash = async (sourceHash, replace) => {
  if (_loading) return
  _loading = true
  _save = undefined
  const [exPath, versionPath=''] = sourceHash.replace(/^#(\/?)/, '').split('@')
  const version = versionPath
    ? defaults(unslash(versionPath).split('/'), 'nan-academy', 'js-training', 'gh-pages').join('/')
    : ''
  const url = version ? `${userContent}/${version}` : contentUrl
  const [mod, ex] = defaults(exPath.split('.'), 'hello', 'introduction').map(decodeURIComponent)
  localStorage[`$${mod}.@${version}`]
    ? loadModule(JSON.parse(localStorage[`$${mod}.@${version}`]))
    : (await importText(await (await fetch(`${url}/module/${mod}.js`)).text()).then(exports => {
      const { next, exercises } = exports
      localStorage[`$${mod}.@${version}`] = JSON.stringify({ next, exercises })
      loadModule(exports)
    }))

  _module.purge = () => localStorage.removeItem(`$${mod}.@${version}`)
  _module.version = version ? `@${version}` : ''
  _module.name = mod

  const exercise = _module.exercises[ex] || _module.entries[0] && _module.entries[0][1]
  if (!exercise) return cmEditor.setValue('Empty module')
  const hash = `#${mod}.${exercise.name}${_module.version}`
  const s = store[hash]
  const pushType = replace ? 'replaceState' : 'pushState'
  hash === location.hash || history[pushType]({}, '', `${baseUrl}${location.search}${hash}`)
  getPage() && getPage().onLoad && getPage().onLoad()
  const content = await getContent(url, exercise.name)
  const subjectIndex = content.indexOf(ZAP) + ZAP.length
  const testIndex = content.lastIndexOf(ZAP)
  const subject = content.slice(0, subjectIndex)
  const tests = content.slice(testIndex)
  const code = `\n\n${(s.code.setnx(content.slice(subjectIndex, testIndex))).trim()}\n\n`
  const subjectLines = countLines(subject)
  const testsLines = countLines(tests)
  const codeLines = countLines(code)
  const size = subjectLines + codeLines

  _error && (_error.clear(), _error = undefined)
  document.body.className = ''
  cmEditor.setValue(`${subject}${code}${tests}`)
  cmEditor.focus()
  cmEditor.setCursor(subjectLines + 2, 0)
  const readOnly = true
  mark({ from: 0, to: subjectLines + 1, readOnly, className: 'subject' })
  mark({ from: subjectLines, to: size, className: 'code' })
  mark({ from: size, to: size + codeLines + 1, readOnly, className: 'tests' })
  _save = () => s.code.set(cmEditor.getValue().slice(subjectIndex, -tests.length).trim())

  let count = 0
  tests.replace(/\nt\(/g, (match, index) => {
    const line = size + countLines(tests.slice(0, index + match.length - 1))
    const matchLines = match.split('\n')
    const lastMatchedLine = matchLines[matchLines.length-1]
    const className = `test-flash test-${++count}`
    mark({ from: line, to: line + 1, className })
  })
  s.begin.setnx(Date.now())
  _loading = false
}

const rand = () => Math.random().toString(36).slice(2).padStart(11, '0')
const sess = `session=${localStorage.session || (localStorage.session = rand())}`
const log = localhost.has(location.hostname) ? console.log : (path, data) => {
  typeof data === 'string' || (data = parametrize(data))
  fetch(`https://chupato.com/log/${unslash(path)}?${sess}&${data}`).catch(() => {})
}

const next = () => {
  const [ path, version = '' ] = location.hash.split('@')
  const [ mod, current ] = path.split('.')
  const next = _module.exercises[current] && _module.exercises[current].next
  if (next) return loadHash(`${mod}.${next.name}@${version}`)
  if (_module.next) return loadHash(`${_module.next}@${version}`)
  loadHash('success.congratulation@nan-academy/js-training')
}

let _lastCode
const runTests = async () => {
  if (_lock) return
  _error && (_error.clear(), _error = undefined)
  const { hash, hostname } = location
  const s = store[hash]
  const end = s.end.get()
  const attempt = end ? s.attempt.get() : s.attempt.set((s.attempt.get() || 0) + 1)
  const code = cmEditor.getValue()
  await (_lock = exec(code)).finally(() => _lock = undefined)
  if (end) return
  const fail = Array.from(document.body.classList).some(c => c.endsWith('-fail'))
  const changed = code !== _lastCode
  _lastCode = code
  changed && log(fail ? 'fail' : 'pass', { hash, attempt, code: save() })
  if (fail) return
  s.end.setnx(Date.now())
  await new Promise(s => setTimeout(s, 250))
  const current = _module.exercises[hash.split('@')[0].split('.')[1]]
  const [lastFeedbackTime] = Object.entries(localStorage)
    .filter(([k]) => k.endsWith('/prompted'))
    .map(([k,v]) => Number(v))
    .sort((a, b) => b - a)

  const canAsk = current
    && current.feedback  // Only if the module ask for it
    && !s.prompted.get() // Once per exercise
    && (lastFeedbackTime

      // Once per hour
      ? (Date.now() - lastFeedbackTime) > 60*60*1000

      // Randomized 20% for the first prompt
      : Math.random() < 0.2
    )

  if (canAsk) {
    s.prompted.set(Date.now())
    open('feedback')
  }

  next()
}

export const cmEditor = CodeMirror(document.getElementById('editor'), {
  mode: 'javascript',
  theme: document.documentElement.classList.contains('dark') ? 'dracula' : 'neo',
  keyMap: 'sublime',
  tabSize: 2,
  lineNumbers: true,
  indentWithTabs: false,
  autoCloseBrackets: true,
  scrollbarStyle: 'null',
  extraKeys: { 'Ctrl-S': runTests, 'Cmd-S': runTests, 'Ctrl-Enter': runTests }
})

const save = () => _save && _save()
cmEditor.on('change', (t => () => (clearTimeout(t), t = setTimeout(save, 200)))())

addEventListener('hashchange', () => loadHash(location.hash, true))
addEventListener('keydown', e => {
  e.key === 'Escape' && getPage().onEscape && getPage().onEscape()
}, { passive: true })

feedback.addEventListener('submit', async e => {
  e.preventDefault()
  open('editor')
  const s = store[feedback.hash]
  if (s.feedbackStatus.get() === 'sending') return
  s.feedbackStatus.set('sending')
  // disable buttons
  await log('feedback', s.feedback.get())
  // re-enable buttons
  // submit value = update
  s.feedbackStatus.set('done')
})
window.cm = cmEditor

skipButton.addEventListener('click', () => open('editor'), { passive: true })

const onOpenFeedback = () => {
  feedback.hash = location.hash
  const prevFeedback = decodeFeedback()
  for (const input of inputs) {
    const v = prevFeedback[input.name]
    v === undefined
      ? (input.value = input.type === 'range' ? 50.01 : '')
      : (v && (input.value = v))
  }
  remarks.focus()
}

const createLink = hash => {
  const a = document.createElement('a')
  const url = `${baseUrl}${location.search}${hash}`

  location.hash === hash && a.classList.add('active')
  a.textContent = hash.slice(1)
  a.classList.add('ui')
  a.href = url

  a.addEventListener('click', e => {
    e.preventDefault()
    loadHash(hash)
  })

  menu.appendChild(a)
  return a
}

const { open, getPage, pages } = router({
  editor: {
    onOpen: () => {
      cmEditor.refresh()
      cmEditor.focus()
    },
    onEscape: () => open('menu'),
  },
  menu: {
    onOpen: () => feedbackBtn.focus(),
    onLoad: () => {
      let elem = menu // empty the menu
      while (elem && elem.firstChild) { elem.removeChild(elem.firstChild) }
      if (!_module) return
      for (const [name, props] of _module.entries) {
        const hash = `#${_module.name}.${name}${_module.version}`
        const s = store[hash]
        const a = createLink(hash)
        a.classList.add(s.end.get() ? 'pass' : s.begin.get() ? 'fail' : 'none')
      }
      if (!_module.next) return
      const next = createLink(`#${_module.next}${_module.version}`)
      next.textContent = `next: ${_module.next}`
    },
    onEscape: () => open('editor'),
  },
  feedback: {
    onOpen: onOpenFeedback,
    onClose: () => store[feedback.hash].feedback.set(encodeFeedback()),
    onEscape: () => open('editor'),
  },
})

dark.addEventListener('change', () => {
  document.documentElement.classList.add('dark')
  cm.setOption('theme', 'dracula')
  localStorage.theme = 'dark'
})

light.addEventListener('change', () => {
  document.documentElement.classList.remove('dark')
  cm.setOption('theme', 'neo')
  localStorage.theme = 'light'
})

feedbackBtn.addEventListener('click', () => open('feedback'))

loadHash(location.hash, true)
  .catch(err => {
    console.error(err)
    _module
      ? _module.purge()
      : localStorage.clear()
    location.hash = ''
  })

  </script>
</body>
</html>